##6.9 切片

切片在语法上看起来与子界类型相似，但是它用于不同的语境中。一个切片仅仅是Slice类型的一个对象，它包含两个边界，a和b。一个切片本身不是很有用，但是其他集合类型定义操作接受切片对象来定义范围。

切片在模块system中的定义为：
```
type
  Slice*[T] = object ## builtin slice type
    a*, b*: T        ## the bounds
```

由定义可以看出切片是一个泛型的对象，它有两个边界：a和b。

字符串使用切片：
```
var 
  x: Slice[int]
  str = "012345"
x.a = 0
x.b = 2
echo str[x]
```
#
数组使用切片：
```
var
  x: Slice[int]
  arr = [0, 1, 2, 3, 4, 5]

x.a = 0
x.b = 2
echo arr[x][0..1]
```
#

```
var x = "012345"
echo x[0..2]
echo x[^2..^1]     #^表示负号
echo x[0..^1]
echo x[..2]
#echo x[0..]      #error

x[1..3] = "abc"       # 赋值长度相同
echo x           #echo  0abc45

x[1..3] = "abcdef"    #大于切片长度    原来的abc替换成了abcdef
echo x        #echo  0abcdef45

x[1..3] = "12"       #小于切片长度     原来的abc替换成了12
echo x        #echo  012def45
```
#

```
var
  a = "Nim is a progamming language"
  b = "Slices are useless."

echo a[7..12] # --> 'a prog'
b[11..^2] = "useful"
echo b # --> 'Slices are useful.'
```

运算符 `..` 返回一个序列，我们也可以定义另一个运算符来实现其功能：
```
proc `@@`*[T](a, b: T): Slice[T] {.noSideEffect, inline, magic: "DotDot".} =
  ## `slice`:idx: operator that constructs an interval ``[a, b]``, both `a`
  ## and `b` are inclusive. Slices can also be used in the set constructor
  ## and in ordinal case statements, but then they are special-cased by the
  ## compiler.
  result.a = a
  result.b = b

proc `@@`*[T](b: T): Slice[T] {.noSideEffect, inline, magic: "DotDot".} =
  ## `slice`:idx: operator that constructs an interval ``[default(T), b]``
  result.b = b

var x = "abcdefgh"
echo x[0@@2]
echo x[@@2]
```

In the previous example slices are used to modify a part of a string. The slice's bounds can hold any value supported by their type, but it is the proc using the slice object which defines what values are accepted.    

在上面的例子中切片被用于改变字符串的一部分。切片的边界可以容纳它们的类型支持的所有值，但是它是使用了切片对象的proc，定义什么值被接受。


# 任真
***
## 6.9 切片
***
片段在语法中类似与子界类型，但是它用于一个不同的背景下。一个片段仅仅是一个类型对象，它包含两个边界，a和b。一个片段本身不是非常有用，但是其他的集合类型定义的操作接受片段对象定义范围。
```
var
  a = "Nim is a progamming language"
  b = "Slices are useless."

echo a[7..12] # --> 'a prog'
b[11.. -2] = "useful"                   (“-”号已换成”^”)  注：版本v0.10.2中使用b[11.. -2] = "useful"
echo b # --> 'Slices are useful.'
```
在上面的例子中，片段被用于修改一个字符串的一部分，甚至使用了一个负数索引。片段边界可以容纳任何被它们的类型支持的值，但是这是过程使用了片段对象，片段对象定义了接受什么样的值。

切片类型在字符串中的作用:假设,切片类型的上下界为a.b
* 索引值从左往右0..string.len-1;索引值从右往左:-(string.len)..-1
* 界限值a,b都不能越界,否则出现越界错误
* 从索引上界处开始依次替换字符串;若索引位置a在b的左侧,则替换索引a到b之间的字符串;若索引位置a在b的右侧,则替换从索引位置a开始,替换将要替换字符串长度的字符,替换向后进行
```
var
  a = "Nim is a progamming language"
  b = "Slices are useless." 


echo a[7..12] 
b[11..^2] = "useful"            #字符串b,索引(从左往右)从0开始,索引(从右往左)从-1开始,b[11..^2] = "useful"之间的字符串替换为"useful".
echo b

b[0.. ^2] = "useful"
echo b  

b = "Slices are useless." 
b[^2.. 10] = "123456"        #将从索引-2开始的字符串替换为"123456"
echo b


b = "Slices are useless." 
b[^2..^6] = "X"
echo b

discard """

b = "Slices are useless." 
b[^2..150] = "Xseful7891011"    #这个时候编译会出错    索引超界
echo b


b = "Slices are useless." 
b[^2..^1000] = "Xseful7891011"    #同上,索引超界
echo b  
```

