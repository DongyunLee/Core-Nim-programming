##6.9 切片

切片在语法上看起来与子界类型相似，但是它用于不同的语境中。一个切片仅仅是Slice类型的一个对象，它包含两个边界，a和b。一个切片本身不是很有用，但是其他集合类型定义操作接受切片对象来定义范围。

切片在模块system中的定义为：
```
type
  Slice*[T] = object ## builtin slice type
    a*, b*: T        ## the bounds
```

由定义可以看出切片是一个泛型的对象，它有两个边界：a和b。

字符串使用切片：
```
var 
  x: Slice[int]
  str = "012345"
x.a = 0
x.b = 2
echo str[x]
echo(x is Slice)       #判断x是否是Slice类型
```
#
数组使用切片：
```
var
  x: Slice[int]
  arr = [0, 1, 2, 3, 4, 5]

x.a = 0
x.b = 2
echo arr[x][0..1]
```
#

```
var x = "012345"
echo x[0..2]
echo x[^2..^1]     #^表示负号
echo x[0..^1]
echo x[..2]
#echo x[0..]      #error

x[1..3] = "abc"       # 赋值长度相同
echo x           #echo  0abc45

x[1..3] = "abcdef"    #大于切片长度    原来的abc替换成了abcdef
echo x        #echo  0abcdef45

x[1..3] = "12"       #小于切片长度     原来的abc替换成了12
echo x        #echo  012def45
```
#

```
var
  a = "Nim is a progamming language"
  b = "Slices are useless."

echo a[7..12] # --> 'a prog'
b[11..^2] = "useful"
echo b # --> 'Slices are useful.'
```

运算符 `..` 返回一个序列，我们也可以定义另一个运算符来实现其功能：
```
proc `@@`*[T](a, b: T): Slice[T] {.noSideEffect, inline, magic: "DotDot".} =
  ## `slice`:idx: operator that constructs an interval ``[a, b]``, both `a`
  ## and `b` are inclusive. Slices can also be used in the set constructor
  ## and in ordinal case statements, but then they are special-cased by the
  ## compiler.
  result.a = a
  result.b = b

proc `@@`*[T](b: T): Slice[T] {.noSideEffect, inline, magic: "DotDot".} =
  ## `slice`:idx: operator that constructs an interval ``[default(T), b]``
  result.b = b

var x = "abcdefgh"
echo x[0@@2]
echo x[@@2]
```

In the previous example slices are used to modify a part of a string. The slice's bounds can hold any value supported by their type, but it is the proc using the slice object which defines what values are accepted.    

在上面的例子中切片被用于改变字符串的一部分。切片的边界可以容纳它们的类型支持的所有值，但是它是使用了切片对象的proc，定义什么值被接受。

```
var x = (0..2)
echo x is Slice            #echo true
echo((0..2) is Slice)        #echo false

var arr = [0,1,2,3,4,5,6,7,8,9]
echo arr[x]
echo arr[0..8][0..5][0..3][x]

var y = (0..5)
echo arr[y][x]
```
#

```
var
  x = (0..5)
  y = (1..3)
  z = ('a'..'f')
  xx = ("a".."f")
  yy = ("aa".."ff")
  zz = ([0,1,2]..[3,4,5])
  xxx = ("abc".."lmn")

echo contains(x, 0)
echo contains(x, 3)
echo contains(x, 6)
echo contains(z, 'b')
echo contains(xx, "b")
echo contains(yy, "bb")
#echo contains(zz, [0,1,2])    #error

echo contains(xxx, "def")     
echo contains(xxx, "aaa")    #false   
echo contains(xxx, "adf")
echo contains(xxx, "cba")
echo contains(xxx, "bbb")    #true

echo(3 in x)
```
#

```
var x = (0..5)
echo(x is Slice)
for i in x:
  echo i

var y = ('a'..'f')
echo(y is Slice)
for i in y:
  echo i

var z = ("a".."f")
echo(z is Slice)
#for i in z:               #error
  #echo i
  
var xx = (1.1..2.1)
#for i in xx:             #error
  #echo i

```
#
```
var x = (1..3)   #切片
echo x 
echo(x is Slice)

var y = {1..3}    #集合     y = {x}  #error
echo y
echo(y is set)

echo((1..3) is set)
```
***






# 任真
***
## 6.9 切片
***
片段在语法中类似与子界类型，但是它用于一个不同的背景下。一个片段仅仅是一个类型对象，它包含两个边界，a和b。一个片段本身不是非常有用，但是其他的集合类型定义的操作接受片段对象定义范围。
```
var
  a = "Nim is a progamming language"
  b = "Slices are useless."

echo a[7..12] # --> 'a prog'
b[11.. -2] = "useful"                   (“-”号已换成”^”)  注：版本v0.10.2中使用b[11.. -2] = "useful"
echo b # --> 'Slices are useful.'
```
在上面的例子中，片段被用于修改一个字符串的一部分，甚至使用了一个负数索引。片段边界可以容纳任何被它们的类型支持的值，但是这是过程使用了片段对象，片段对象定义了接受什么样的值。

切片类型在字符串中的作用:假设,切片类型的上下界为a.b
* 索引值从左往右0..string.len-1;索引值从右往左:-(string.len)..-1
* 界限值a,b都不能越界,否则出现越界错误
* 从索引上界处开始依次替换字符串;若索引位置a在b的左侧,则替换索引a到b之间的字符串;若索引位置a在b的右侧,则替换从索引位置a开始,替换将要替换字符串长度的字符,替换向后进行
```
var
  a = "Nim is a progamming language"
  b = "Slices are useless." 


echo a[7..12] 
b[11..^2] = "useful"            #字符串b,索引(从左往右)从0开始,索引(从右往左)从-1开始,b[11..^2] = "useful"之间的字符串替换为"useful".
echo b

b[0.. ^2] = "useful"
echo b  

b = "Slices are useless." 
b[^2.. 10] = "123456"        #将从索引-2开始的字符串替换为"123456"
echo b


b = "Slices are useless." 
b[^2..^6] = "X"
echo b

discard """

b = "Slices are useless." 
b[^2..150] = "Xseful7891011"    #这个时候编译会出错    索引超界
echo b


b = "Slices are useless." 
b[^2..^1000] = "Xseful7891011"    #同上,索引超界
echo b  
```

