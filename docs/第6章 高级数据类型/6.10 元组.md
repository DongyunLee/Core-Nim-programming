##6.10 元组

一个元组变量或对象变量是一个异构的存储容器。它们可以存储不同类型的数据，一个元组或对象定义了各种命名字段的类型，元组也定义了字段的顺序。元组作为异构存储类型意味着没有开销和很少可能抽象。我们可以通过构造器 () 来构造元组。在构造器中字段的顺序应该与元组定义时的顺序相同。如果不同的元组类型它们的字段是相同的名称和类型，并且有相同的命名顺序，那么可以认为它们是相同的。

    type 
      student = tuple[name: string, age: int]
      teacher = tuple[name: string, age: int]
    
    var
      x: student
      y: teacher
    x = (name: "yrs", age: 22)
    y = (name: "abc", age: 44)
    echo x
    x = y
    echo x


赋值运算符对于元组将会复制每一个部分，符号t.field是用于访问一个元组的字段。其他的方式是 t[i] 是访问第i个字段。这里的i需要是一个整型常量。

    type
      Person = tuple[name: string, age: int] # type representing a person:
                                             # a person consists of a name
                                             # and an age
    var
      person: Person
    person = (name: "Peter", age: 30)
    # the same, but less readable:
    person = ("Peter", 30)
    
    echo(person.name) # "Peter"
    echo(person.age)  # 30
    
    echo(person[0]) # "Peter"
    echo(person[1]) # 30
    
    # You don't need to declare tuples in a separate type section.
    var building: tuple[street: string, number: int]
    building = ("Rue del Percebe", 13)
    echo(building.street)
    
    # The following line does not compile, they are different tuples!
    #person = building
    # --> Error: type mismatch: got (tuple[street: string, number: int])
    # but expected 'Person'
    
    # The following works because the field names and types are the same.
    var teacher: tuple[name: string, age: int] = ("Mark", 42)
    person = teacher


虽然你不需要为了使用一个元组而声明一个类型，但是以不同的字段命名创建的元组将会被认为是不同的对象，尽管有相同的子段类型。

    var
      x: tuple[names: string, ages: int]
      y: tuple[name: string, age: int]
    x = (name: "yrs", age: 22)
    y = (name: "abc", age: 44)
    echo x
    x = y     #error  type mismatch
    echo x

在变量赋值时元组可以被打开（也只有这时），这个可以方便的直接赋给元组单独命名的字段变量，一个相关的例子是来自os模块的splitFile过程，它将同时返回目录、文件名和扩展名，对于元组拆箱工作，你不得不用圆括号括起要赋值的变量，不然将为所有的变量赋相同的值！例如：

    import os
    
    let
      path = "usr/local/nimc.html"
      (dir, name, ext) = splitFile(path)
      baddir, badname, badext = splitFile(path)
    echo dir            # outputs `usr/local`
    echo name           # outputs `nimc`
    echo ext            # outputs `.html`
    # All the following output the same line:
    # `(dir: usr/local, name: nimc, ext: .html)`
    echo baddir
    echo badname
    echo badext


元组拆箱也可以工作在var或let块外

    import os
    
    var
      path = "usr/local/nimc.html"
      dir, name, ext = ""
    
    (dir, name, ext) = splitFile(path)
    echo dir   
    echo name
    echo ext

元组也可以像声明一个对象一样定义，在type中可以通过缩进来代替 []：

    type
      Person = tuple   # type representing a person
        name: string   # a person consists of a name
        age: Natural   # and an age  Natural* = range[0..high(int)]
    
    var student:Person 
    student = (name: "yrs", age: Natural(22))
    echo(student)
#

    proc `^` (a, b: int): int =
      result = 1
      for i in 1..b: result = result * a
    
    var m = (0, 5)
    var n = (56, 3)
    
    m = (n[0] + m[1], m[1] ^ n[1])
    
    echo m[0], ", ", m[1] 

#

    type
      Item[K,V] = tuple
        key: K
        value: V
    
    var q = newseq[Item[int,int]](1) 
    q[0].key = 1
    q[0].value = 2
    let (x,y) = q[0]
    echo (x,y)

#

    proc test(): int64 =
      return 0xdeadbeef.int64
    
    const items = [
      (var1: test(), var2: 100'u32),
      (var1: test(), var2: 192'u32)
    ]
    
    echo items[0]
    echo items[1]