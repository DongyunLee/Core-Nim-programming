##6.4 集合类型
集合类型模拟了数学上的概念：集合。集合的基类型只能是一种具有一定规模的序数类型，也就是：

- int8-int16


- uint8/byte-uint16


- char


- enum

或者等价物。原因是集合是以高性能位向量来实现的，试图用一个大类型来声明一个集合将会导致一个错误：

    var s: set[int64] # Error: set is too large

我们能够通过集合构造器来构造一个集合：{}是一个空集合，空集合是兼容任何的集合类型，构造器也可以带有元素（和元素的范围）：

    type
      IntSet = set[int8]
    
    var
      x: IntSet
    x = {1'i8,2'i8,3'i8,4'i8,5'i8}
    echo x

#

    type
      color = enum
        red, yellow, blue, green, white
    
      enumSet = set[color]
#     
    var
      x: enumSet
    x = {yellow..green}
    echo x

    type
      CharSet = set[char]
    var
      x: CharSet
    x = {'a'..'z', '0'..'9'} # This constructs a set that contains the
                             # letters from 'a' to 'z' and the digits
                             # from '0' to '9'
    echo x

下面这些操作符是可以用于集合的：

<table>
   <tr>
      <td>operation</td>
      <td>meaning</td>
   </tr>
   <tr>
      <td>A + B</td>
      <td>union of two sets</td>
   </tr>
   <tr>
      <td>A * B</td>
      <td>intersection of two sets</td>
   </tr>
   <tr>
      <td>A - B</td>
      <td>difference of two sets (A without B's elements)</td>
   </tr>
   <tr>
      <td>A == B</td>
      <td>set equality</td>
   </tr>
   <tr>
      <td>A <= B</td>
      <td>subset relation (A is subset of B or equal to B)</td>
   </tr>
   <tr>
      <td>A < B</td>
      <td>strong subset relation (A is a real subset of B)</td>
   </tr>
   <tr>
      <td>e in A</td>
      <td>set membership (A contains element e)</td>
   </tr>
   <tr>
      <td>e notin A</td>
      <td>A does not contain element e</td>
   </tr>
   <tr>
      <td>contains(A, e)</td>
      <td>A contains element e</td>
   </tr>
   <tr>
      <td>card(A)</td>
      <td>the cardinality of A (number of elements in A)</td>
   </tr>
   <tr>
      <td>incl(A, elem)</td>
      <td>same as A = A + {elem}</td>
   </tr>
   <tr>
      <td>excl(A, elem)</td>
      <td>same as A = A - {elem}</td>
   </tr>
</table>


<table>
   <tr>
      <td>operation</td>
      <td>meaning</td>
   </tr>
   <tr>
      <td>A + B</td>
      <td>两个集合的并集</td>
   </tr>
   <tr>
      <td>A * B</td>
      <td>两集合的交集</td>
   </tr>
   <tr>
      <td>A - B</td>
      <td>两个集合的差集(A中没有B中的元素)</td>
   </tr>
   <tr>
      <td>A == B</td>
      <td>集合相等</td>
   </tr>
   <tr>
      <td>A <= B</td>
      <td>子集关系 (A是B的子集或者与B相等)</td>
   </tr>
   <tr>
      <td>A < B</td>
      <td>强子集关系 (A是 B的真正子集)</td>
   </tr>
   <tr>
      <td>e in A</td>
      <td>集员关系 (A 包含元素 e)</td>
   </tr>
   <tr>
      <td>e notin A</td>
      <td>A 不包含元素 e</td>
   </tr>
   <tr>
      <td>contains(A, e)</td>
      <td>A 包含元素 e</td>
   </tr>
   <tr>
      <td>card(A)</td>
      <td>集合A的基数(A中元素数量)</td>
   </tr>
   <tr>
      <td>incl(A, elem)</td>
      <td>same as A = A + {elem}</td>
   </tr>
   <tr>
      <td>excl(A, elem)</td>
      <td>same as A = A - {elem}</td>
   </tr>
</table>


    type
      CharSet = set[char]
    var
      x, y, z: CharSet
      
    x = {'a'..'z', '1'..'3'} 
    y = {'0'..'9', 'a'..'c'}
    
    z = x + y
    echo z
    
    z = x * y
    echo z
    
    z = x - y
    echo z
    
    echo x == y
    echo x <= y
    echo x < y
    
    echo 'z' in x
    echo '0' notin x
    echo contains(y,'0')
    echo card(y)
    
    incl(x,'4')
    echo x
    excl(x,'1')
    echo x

#

    var s, s1: set[char]
    s = {'a'..'d'}
    s1 = {'a'..'c'}
    echo s1 < s
    echo s1 * s == {'a'..'c'}
    echo s1 <= s



Sets are often used to define a type for the flags of a procedure. This is a much cleaner (and type safe) solution than just defining integer constants that should be or'ed together.

集合通常用来为过程的flags定义一个类型，这是一个更清洁（和类型安全的）解决方案，与仅仅定义应该和or一起的整型常量相比。