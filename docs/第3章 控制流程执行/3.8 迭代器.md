##3.8 迭代器
让我们回到这个无聊的计数的例子：

    echo("Counting to ten: ")
    for i in countup(1, 10):
      echo($i)

写一个countup过程能不能支持这个循环呢？让我们试一下：

    proc countup(a, b: int): int =
      var res = a
      while res <= b:
        return res
        inc(res)

然而这个是不能工作的，问题是过程不仅仅只有返回，而是既需要返回，也需要在一次迭代完后继续下一次迭代执行。很明显这个程序中，while语句第一次遇到return后该过程就结束了。要想实现就有返回，又有能继续迭代，就需要用到yield语句。现在就让我们使用关键字iterator代替proc，yield语句代替return语句来实现我们的第一个迭代器：

    iterator countup(a, b: int): int =
      var res = a
      while res <= b:
        yield res
        inc(res)

迭代器看起来和过程非常相似，但是它们之间有一些重要的区别：


1. 迭代器仅仅能够for循环调用


1. 迭代器不能包含return语句，过程不能包含yield语句


1. 迭代器没有隐含result变量


1. 迭代器不支持递归


1. 迭代器不能被前置声明，因为编译器必须能够内联一个迭代器。（在未来版本的编译器中这个限制将会消失。
  
有时候迭代器也是可以省略的

    # this definition exists in the system module
    iterator items*(a: string): char {.inline.} =
      var i = 0
      while i < len(a):
        yield a[i]
        inc(i)
    
    for ch in items("hello world"): # `ch` is an iteration variable
      echo(ch)

这个items迭代器在system模块中有定义。它的参数也有不同的类型，它的功能是返回参数（数组，字符串，序列等等）的单元量。你也可以省略items，直接写一个参数，这样编译器编译时会添加items。

例如上面的程序：

    for ch in items("hello world"): # `ch` is an iteration variable
      echo(ch)

可以改写为：

    for ch in "hello world": # `ch` is an iteration variable
      echo(ch)

再例如：

    for x in [1,2,3]:
      echo x
  
会被编译器改写为：

    for x in items([1,2,3]):
      echo x

  
如果for循环有两个变量，那么会隐式的调用pairs迭代器。

    for i, value in [2,4,6]:
      echo "index: ", i, " value: ", value

同样相当于：

    for i, value in pairs([2,4,6]):
      echo "index: ", i, " value: ", value

Nim不仅使用迭代器方便，而且还可以很容易的自己定义一个迭代器，请看下面这段代码：

    iterator mySquare(a, b: int): int = 
      var res = a
      while res <= b:
        yield res*res
        inc(res)
    
    for i in mySquare(1,5):
      echo i

自己定义一个运算符迭代器：

    iterator `...`*[T](a: T, b: T): T = 
      var res: T = T(a)
      while res <= b:
        yield res
        inc res

    for i in 0...5:
      echo i
