##3.5 作用域和block语句
前面我们介绍了if,case,while和for等控制流语句。目前为止控制流语句有一个特性我们还没有概括：控制流打开一个新的作用域。因此对于下面的例子中变量x在循环外是不能被访问的：

    while false:
      var x = "hi"
    echo(x) # does not work

一个while（或for）语句引进一个隐式的块，标识符只能在它声明的块中可见。block语句能够被用于明确地声明一个新的块：
  
    block myblock:
      var x = "hi"
    echo(x) # does not work either 
    
即等价于:

    block:
       var x = "hi"
    echo(x) # does not work either


###作用域规则：
标识符的有效范围是从它的定义开始，一直到它的定义所在的块结束为止。标识符可知的范围就是标识符的作用域。标识符确切的作用域依赖于它声明的方式。

###block作用域：
在一个块中声明一个变量，它的有效作用域是：从变量声明开始，到这个块结束为止。如果一个块中包含另一个块，第二个块中重新声明了第一个块中的标识符，那么在这个第二个块中，第二次声明是有效的，在第二个块外，第一个块内，第一次定义的标识符是有效的。在同一个块中标识符不能被重新定义，除非是为了重载过程或迭代器。

###元组或对象作用域：
一个定义的元组或对象的字段标识符在以下情况下是有效的：


1. 元组或对象定义所在的块内


1. 元组或对象类型所给的一个变量的字段标志符


1. 这个对象的所有子孙类型


###模块作用域：
一个模块的所有标识符从它定义开始到这个模块结束都是有效的。来自简介依赖模块的标识符是无效的。system模块是自动导入到每个模块的。

如果一个模块通过两个不同的模块导入一个标识符，那么每一个出现的标识符将会被限制，除非它是一个重载的过程或迭代器，在这种情况下重载解析将会发生：
 
    # Module A
    var x*: string
#
    # Module B
    var x*: int
#
    # Module C
    import A, B
    write(stdout, x) # error: x is ambiguous
    write(stdout, A.x) # no error: qualifier used

    var x = 4
    write(stdout, x) # not ambiguous: uses the module C's x

上面三个模块对应与三个Nim文件，分别命名为A，B，C。其中在A和B模块中变量x后面的*，表示可以通过import语句导入到其他模块使用。这里需要注意的是，如果在Windows下运行C.nim程序，C模块中的A.x 表达式要改为a.x，因为在Windows下，字母都被认为是小写。
