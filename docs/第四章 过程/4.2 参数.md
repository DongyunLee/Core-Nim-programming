##4.2 参数
在Nim中有两种类型的参数，一种是在过程体内不允许改变其值的参数，另一种是允许改变其值的参数。第一种不允许改变该值是为了是编译器能够以最高效的方式传递参数，例如前面我们写过得例子：

    proc sum(a, b: int): int = 
      result = a + b
    
    echo sum(1,2)
    
在sum过程中不允许改变a或者b的值，如果添加语句a = a+1，这样在程序编译时会出现错误，提示信息： Error: 'a' cannot be assigned to。

那如果我们想要在过程体中改变参数怎么办呢？这就要讲到第二种参数了，要想在过程体中改变参数的值，可以在函数定义的时候在类型前添加关键字var。例如：

    proc sum(a, b: var int): int = 
      a = a + 1
      result = a + b
    
    var a, b = 1
    echo sum(a,b) #echo 3
    echo a  #echo 2
   
这样就可以改变参数a和b的值了，并且这样改变了a的真实值，在sum过程外，a的值也随之而变。

那我们来再看一个例子，看看为什么在过程中改变参数的值，过程结束后实参的值也随之而变。

    proc divmod(a, b: int; res, remainder: var int) =
      res = a div b
      remainder = a mod b
    var
      x, y: int
    divmod(8, 5, x, y) # modifies x and y
    assert x == 1
    assert y == 3

在上面的例子中，a,b是不带 var 的参数，它们在过程中是不允许改变的，而 res, remainder 在过程中是能够改变其值的。 这里需要注意的是：传递给 var 参数的必须是一个 l-value.
    
l-value 介绍：
 一个表达式能指定一个产生一个值或位置的计算。产生位置的表达式就是 l-values。（比如：var x = 5 中的 x 就是一个l-value。 5 就不是）。一个 l-value 能够表示一个位置或者这个位置包含的值，这取决于语境。表达式的值能够被静态确定的被称为常量表达式。它们不是 l-values。let 声明的变量不是 l-values。

其实var 参数是作为隐式的指针实现的，上面的例子与这个例子是等价的：

    proc divmod(a, b: int; res, remainder: ptr int) =
      res[] = a div b
      remainder[] = a mod b
    
    var
      x, y: int
    divmod(8, 5, addr(x), addr(y))
    assert x == 1
    assert y == 3

上面的例子中，ptr表示的是指针类型，调用过程divmod时addr(x)和addr(y)表示的是x和y的地址。由此可以看出以var类型参数传递的是地址，通过指针来改变实参的值。


###多种类型参数表示

在定义一个过程时，很可能有多种类型的参数，那么我们怎么去表示呢。
    
（1）使用逗号分割 

    proc strAdd(str1: var string, str2: string, n: bool) = 
      if n:
        str1 = str1 & str2
    
    var 
      str1 = "yr"
    strAdd(str1,"ss",true)
    echo str1         #echo  yrss

（2）使用分号分割

    proc strAdd(str1: var string; str2: string; n: bool) = 
      if n:
        str1 = str1 & str2
    
    var 
      str1 = "yr"
    strAdd(str1,"ss",true)
    echo str1

当然你也可以混合使用，但是这样可读性会大大降低。